---
title: "Introducing osmextract"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introducing osmextract}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides an introduction to using the package, building on the README which covers installation and our motivations for creating it.

Loading the package generates important messages about the license associated with OSM data.

```{r setup}
library(osmextract)
```

The first thing to say is: do not ignore this message!
There are important legal considerations that you should be aware of before using OSM data, especially if you are working in a for-profit capacity.

# Legal considerations

Anyone using OSM data is bound by law to adhere to the [ODbL](https://opendatacommons.org/licenses/odbl/summary/) which means that you must:

- Attribute: You must attribute any public use of the database, or works produced from the database, in the manner specified in the ODbL. For any use or redistribution of the database, or works produced from it, you must make clear to others the license of the database and keep intact any notices on the original database.
- Share-Alike: If you publicly use any adapted version of this database, or works produced from an adapted database, you must also offer that adapted database under the ODbL.
- Keep open: If you redistribute the database, or an adapted version of it, then you may use technological measures that restrict the work (such as DRM) as long as you also redistribute a version without such measures.

In short, publicly using OSM data without attribution or selling datasets derived from it is illegal.
See the [License/Use Cases page on the OSM wiki](https://wiki.openstreetmap.org/wiki/License/Use_Cases) for detailed use cases.

# Main package functions

The packages is composed of the following main functions: 

1. `oe_providers()`: Show which providers of OSM extracts are available
1. `oe_match()`: Match the input zone with one of the files stored by the OSM providers
2. `oe_download()`: Download the chosen file
3. `oe_vectortranslate()`: Convert the .pbf files into .gpkg files
4. `oe_read()`: Read the `.gpkg` files
5. `oe_get()`: Match, download, translate and import data in one step

For many users who just want to get OSM data quickly `oe_get()` may be sufficient, as covered in the README.
We will demonstrate each function in turn.

## List providers with `oe_providers()`

`oe_providers()` lists the providers that are currently available with the version of `osmextract` you have installed.

```{r}
oe_providers()
```

Each element in `database_name` is a data object that is packaged with `osmextract`.

```{r}
data(package = "osmextract")
```



## Importing OSM data

Before importing OSM data it is probably first worth loading the `sf` package as follows:

```{r}
library(sf)
```

That gives you access to many geographic functions for working with geographic vector data of the type provided by `osmextract`.


The function `oe_get()` downloads (if not already downloaded) and reads-in data from OSM extract providers as an `sf` object:

```{r}
iow = oe_get("Isle of Wight", stringsAsFactors = FALSE)
class(iow)
names(iow) # default variable names
```

Once imported, we can use all the functions for data frames in base R and other packages.
We can also use functions from the `sf` package for spatial analysis and visualisation.
Let's plot all the major and minor roads, for example:

```{r iow1}
iow_major_roads = iow[iow$highway %in% c("primary", "secondary"), ]
plot(iow_major_roads["highway"])
```

The same steps can be used to get other OSM datasets (note use of `quiet = FALSE` to show additional message, examples not run):

```{r, eval=FALSE}
test_malta = oe_get("Malta", quiet = FALSE)
ncol(test_malta)
test_andorra = oe_get("Andorra", extra_attributes = "ref", quiet = FALSE)
ncol(test_andorra)
```

## Queries

Some files from providers such as geofabrik are large.
You may therefore want to check the contents before importing them.
To do this you can use an SQL query that is passed to GDAL via `sf`.
To check the values stored in the highway column for our Isle of Wight example, for example, run the following command: 

```{r}
oe_get(
  "Isle of Wight", 
  query = "SELECT DISTINCT highway FROM \"lines\" "
)
```

The values will vary.
There are more types of highway in the Andorra dataset, for example:

```{r}
oe_get(
  "Andorra", 
  query = "SELECT DISTINCT highway FROM \"lines\" "
)
```

The same `query` argument can be used to read-in only certain features, all primary roads in Andorra for example: 

```{r, iow2}
# and select only one of them: 
iow_primary = oe_get(
  "Isle of Wight", 
  extra_attributes = "ref", 
  quiet = FALSE, 
  query = "SELECT * FROM 'lines' WHERE highway IN ('primary')"
)
class(iow_primary)
plot(iow_primary$geometry)
```

This is substantially faster and less memory intensive than reading-in the whole dataset and filtering with R.

You can use [GDAL's SQL syntax](https://gdal.org/user/ogr_sql_dialect.html) to get the result you need.
Let's get all primary and secondary roads, for example:

```{r, iow3}
iow_major_roads2 = oe_get(
  "Isle of Wight", 
  extra_attributes = "ref", 
  quiet = FALSE, 
  query = "SELECT * FROM 'lines' WHERE highway IN ('primary', 'secondary')"
)
plot(iow_major_roads2["highway"])
```

You can also use regex, as shown in the following command that gets roads that are likely to be walking and cycling friendly:

```{r, iow4}
iow_active_travel = oe_get(
  "Isle of Wight", 
  extra_attributes = "ref", 
  quiet = FALSE, 
  query = "SELECT * FROM 'lines' WHERE highway IN ('cycleway', 'living_street', 'residential')"
)
plot(iow_active_travel["highway"])
```

## Other providers

At present `geofabrik` and `bbbike` providers are supported.
An example showing how to use an alternative provider is shown in the example below.

```{r, eval=FALSE}
leeds = oe_get(place = "Leeds", provider = "bbbike", quiet = FALSE)
names(leeds)
#> [1] "osm_id"     "name"       "highway"    "waterway"   "aerialway"  "barrier"    "man_made"   "z_order"    "other_tags" "geometry"  
plot(leeds$geometry)
```


```{r, echo=FALSE}
knitr::include_graphics("https://user-images.githubusercontent.com/1825120/87104595-46d8b180-c250-11ea-878f-8936c0a7bd30.png")
```


The package supports downloading, reading and extracting OpenStreetMap data from various providers.
A list of providers can be found at [wiki.openstreetmap.org](https://wiki.openstreetmap.org/wiki/Processed_data_providers).
The first provider supported was [Geofabrik](http://download.geofabrik.de/).
The second was [bbbike](https://download.bbbike.org/osm/bbbike/).
The package can be extended to support additional providers, as seen in [code](https://github.com/ITSLeeds/osmextract/commit/be3b48e7ed7ccd957e988bacad053161247b206d) that adds a working test provider.

Providers break the world into zones.
These zones are represented as `sf` objects that summarize the most important characteristics of each geographic zone, such as the name and the url of the pbf file, as illustrated in the code chunk below.

```{r}
names(geofabrik_zones)
st_drop_geometry(geofabrik_zones[1:3, c(2, 8)])
bbbike_zones$name[1:20]
```


The function `oe_get` is a wrapper around all of them. 

Behind the scenes, the function `oe_read()` is used to translate and read-in `.pbf` files using `sf::st_read()`.
Various configuration options can be used to import additional columns from the `.pbf` files not imported by default, including `maxspeed`, `lanes` and `oneway` (the attributes to include can be set
with `attributes` argument)

# Test `oe_match`

The simplest example: 

```{r}
oe_match("Italy")
oe_match("Isle of wight")
```

There are several situations where it could be difficult to find the appropriate data source due to several small differences in the official names: 

```{r, error = TRUE}
oe_match("Korea")
oe_match("Russia")
```

For these reasons we implemented the possibility to look for the appropriate area according to the [iso3166-1 alpha2](https://it.wikipedia.org/wiki/ISO_3166-1_alpha-2) code: 

```{r}
oe_match("KP", match_by = "iso3166_1_alpha2")
oe_match("RU", match_by = "iso3166_1_alpha2")
oe_match("US", match_by = "iso3166_1_alpha2")
```

The are a few cases where the `iso3166-1 alpha2` codes can fail because there are no per-country extracts (e.g. Israel and Palestine)

```{r, error = TRUE}
oe_match("PS", match_by = "iso3166_1_alpha2")
oe_match("IL", match_by = "iso3166_1_alpha2")
```

For this reason we also created a function that let you explore the matching variables according to a chosen pattern, for example: 

```{r}
oe_check_pattern("London")
oe_check_pattern("Russia")
oe_check_pattern("Korea")
oe_check_pattern("Yorkshire")
oe_check_pattern("US")
oe_check_pattern("US", match_by = "iso3166_2")
oe_check_pattern("Palestine")
israel_sf = oe_check_pattern("Israel", full_row = TRUE)
```

The input `place` can be also specified using an `sfc_POINT` object with arbitrary CRS as documented in the following example. If there are multiple matches, the function returns the smallest area (according to the `level` variable). I would ignore the CRS warning for the moment. 

```{r}
coords_milan = sf::st_point(c(1514924.21, 5034552.92)) # Duomo di Milano
st_sfc_milan = sf::st_sfc(coords_milan, crs = 3003)
oe_match(st_sfc_milan)
```

The input `place` can be also specified using a numeric vector of coordinates. In that case the CRS is assumed to be 4326:

```{r, error = TRUE}
oe_match(c(9.1916, 45.4650)) # Duomo di Milano
oe_match(c(9.1916, 45.4650, 9.2020, 45.4781))
# oe_match(c(9.1916, 45.4650), c(9.2020, 45.4781)) FIXME with suitable check and error
```

If there are several error matching the input place with one of the zone, you can also try increasing the maximum allowed string distance: 

```{r, error = TRUE}
oe_match("Isle Wight")
oe_match("Isle Wight", max_string_dist = 3)
```

## Test `oe_download`

The simplest example: 

```{r}
iow_details = oe_match("Isle of Wight")
oe_download(
  file_url = iow_details$url, 
  file_size = iow_details$file_size
)
```

If you want to download your data into a specific folder once, you can set the download directory: 

```{r, eval=FALSE}
Sys.setenv("OSMEXT_DOWNLOAD_DIRECTORY" = "/home/andrea/Downloads")
oe_download(
  file_url = iow$url, 
  file_size = iow$file_size
)
#> /home/andrea/Downloads/geofabrik_isle-of-wight-latest.osm.pbf
```

If you want to set a directory that will persist, you can set `OSMEXT_DOWNLOAD_DIRECTORY=/path/for/osm/data` in your `.Renviron` file, e.g. with:

```{r, eval=FALSE}
usethis::edit_r_environ()
# Add a line containing: OSMEXT_DOWNLOAD_DIRECTORY=/path/to/save/files
```
